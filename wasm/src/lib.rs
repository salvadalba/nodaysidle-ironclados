use wasm_bindgen::prelude::*;
use serde::{Deserialize, Serialize};
use js_sys::JSON;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global allocator
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// Setup panic hook to provide better error messages in browser console
#[cfg(feature = "console_error_panic_hook")]
fn setup_panic_hook() {
    console_error_panic_hook::set_once();
}

#[cfg(not(feature = "console_error_panic_hook"))]
fn setup_panic_hook() {}

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);

    #[wasm_bindgen(js_namespace = console)]
    fn error(s: &str);

    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn logv(x: &JsValue);
}

macro_rules! console_log {
    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))
}

macro_rules! console_error {
    ($($t:tt)*) => (error(&format_args!($($t)*).to_string()))
}

/// Artifact types supported by the demo engine
#[derive(Debug, Clone, Serialize, Deserialize)]
#[wasm_bindgen]
pub enum ArtifactType {
    PRD,
    ARD,
    TaskList,
}

impl ArtifactType {
    pub fn as_str(&self) -> &'static str {
        match self {
            ArtifactType::PRD => "PRD",
            ArtifactType::ARD => "ARD",
            ArtifactType::TaskList => "TASK_LIST",
        }
    }
}

/// Demo input from user
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DemoInput {
    pub prompt: String,
    pub artifact_type: String,
}

/// Demo output generated by the engine
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DemoOutput {
    pub prd: Option<PRDSection>,
    pub ard: Option<ARDSection>,
    pub task_list: Option<TaskListSection>,
    pub agent_rules: Option<AgentRulesSection>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PRDSection {
    pub title: String,
    pub vision: String,
    pub goals: Vec<String>,
    pub non_goals: Vec<String>,
    pub target_users: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ARDSection {
    pub system_overview: String,
    pub architecture_style: String,
    pub frontend_tech: Vec<String>,
    pub backend_tech: Vec<String>,
    pub data_layer: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskItem {
    pub id: String,
    pub title: String,
    pub description: String,
    pub estimate: String,
    pub dependencies: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskListSection {
    pub epic: String,
    pub tasks: Vec<TaskItem>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentRule {
    pub role: String,
    pub goal: String,
    pub context: String,
    pub files_to_create: Vec<String>,
    pub files_to_modify: Vec<String>,
    pub detailed_steps: Vec<String>,
    pub validation: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentRulesSection {
    pub rules: Vec<AgentRule>,
}

/// Demo engine state
pub struct DemoEngine {
    initialized: bool,
}

impl DemoEngine {
    pub fn new() -> Self {
        Self {
            initialized: false,
        }
    }

    pub fn initialize(&mut self) -> Result<(), String> {
        if self.initialized {
            return Ok(());
        }
        console_log!("Demo engine initializing...");
        self.initialized = true;
        console_log!("Demo engine initialized");
        Ok(())
    }
}

impl Default for DemoEngine {
    fn default() -> Self {
        Self::new()
    }
}

/// Global demo engine instance
static mut ENGINE: Option<DemoEngine> = None;

/// Get or create the global engine instance
fn get_engine() -> &'static mut DemoEngine {
    unsafe {
        if ENGINE.is_none() {
            ENGINE = Some(DemoEngine::new());
        }
        ENGINE.as_mut().unwrap()
    }
}

/// Initialize the WASM module
#[wasm_bindgen]
pub fn initialize() -> Result<(), JsValue> {
    setup_panic_hook();
    console_log!("Initializing Ironclad WASM module...");
    let engine = get_engine();
    engine.initialize().map_err(|e| JsValue::from_str(&e))?;
    Ok(())
}

/// Execute demo with input prompt
#[wasm_bindgen]
pub fn executeDemo(input: &str) -> Result<JsValue, JsValue> {
    console_log!("Executing demo with input: {}", input);

    let engine = get_engine();
    if !engine.initialized {
        return Err(JsValue::from_str("Engine not initialized. Call initialize() first."));
    }

    // Parse input
    let input_str = input.trim();
    if input_str.is_empty() {
        return Err(JsValue::from_str("Input cannot be empty"));
    }

    // Generate demo output
    let output = generate_demo_output(input_str)?;

    // Convert to JSON
    let json_string = serde_json::to_string(&output)
        .map_err(|e| JsValue::from_str(&format!("Failed to serialize output: {}", e)))?;

    // Parse JSON string to JsValue
    let js_value = JSON::parse(&json_string)
        .map_err(|e| JsValue::from_str(&format!("Failed to parse JSON: {:?}", e)))?;

    Ok(js_value)
}

/// Generate demo output from input
fn generate_demo_output(input: &str) -> Result<DemoOutput, String> {
    let _words: Vec<&str> = input.split_whitespace().collect();

    let prd = Some(PRDSection {
        title: format!("Project: {}", input),
        vision: format!("A solution for: {}", input),
        goals: vec![
            "Transform user requirements into actionable software artifacts".to_string(),
            "Provide deterministic, verifiable outputs".to_string(),
            "Enable rapid iteration and validation".to_string(),
        ],
        non_goals: vec![
            "Full code generation in v1".to_string(),
            "Multi-user collaboration in v1".to_string(),
        ],
        target_users: vec![
            "CTOs and Technical Founders".to_string(),
            "Product Managers".to_string(),
            "Engineering Leads".to_string(),
        ],
    });

    let ard = Some(ARDSection {
        system_overview: format!("Client-side SPA with server-side persistence for: {}", input),
        architecture_style: "Event-driven architecture with WASM core".to_string(),
        frontend_tech: vec!["React".to_string(), "TypeScript".to_string(), "Vite".to_string()],
        backend_tech: vec!["Node.js".to_string(), "Express".to_string(), "PostgreSQL".to_string()],
        data_layer: vec!["PostgreSQL".to_string(), "Redis (optional)".to_string()],
    });

    let task_list = Some(TaskListSection {
        epic: format!("Build {}", input),
        tasks: vec![
            TaskItem {
                id: "001".to_string(),
                title: "Initialize project structure".to_string(),
                description: "Set up monorepo with frontend and backend".to_string(),
                estimate: "0.5".to_string(),
                dependencies: vec![],
            },
            TaskItem {
                id: "002".to_string(),
                title: "Implement core features".to_string(),
                description: "Build main functionality".to_string(),
                estimate: "2.0".to_string(),
                dependencies: vec!["001".to_string()],
            },
            TaskItem {
                id: "003".to_string(),
                title: "Add testing and documentation".to_string(),
                description: "Ensure quality and maintainability".to_string(),
                estimate: "1.0".to_string(),
                dependencies: vec!["002".to_string()],
            },
        ],
    });

    let agent_rules = Some(AgentRulesSection {
        rules: vec![
            AgentRule {
                role: "Full Stack Developer".to_string(),
                goal: format!("Initialize project structure for {}", input).to_string(),
                context: "Set up monorepo with workspaces".to_string(),
                files_to_create: vec!["package.json".to_string(), "tsconfig.json".to_string()],
                files_to_modify: vec![],
                detailed_steps: vec![
                    "Create root package.json with workspaces".to_string(),
                    "Configure shared TypeScript".to_string(),
                    "Set up build scripts".to_string(),
                ],
                validation: "npm install runs successfully".to_string(),
            },
        ],
    });

    Ok(DemoOutput {
        prd,
        ard,
        task_list,
        agent_rules,
    })
}

/// Cleanup resources
#[wasm_bindgen]
pub fn cleanup() -> Result<(), JsValue> {
    console_log!("Cleaning up WASM module...");
    unsafe {
        ENGINE = None;
    }
    console_log!("WASM module cleaned up");
    Ok(())
}

/// Get module version
#[wasm_bindgen]
pub fn getVersion() -> String {
    env!("CARGO_PKG_VERSION").to_string()
}

/// Check if engine is initialized
#[wasm_bindgen]
pub fn isInitialized() -> bool {
    unsafe {
        ENGINE.is_some() && ENGINE.as_ref().map(|e| e.initialized).unwrap_or(false)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_engine_initialization() {
        let mut engine = DemoEngine::new();
        assert!(!engine.initialized);
        engine.initialize().unwrap();
        assert!(engine.initialized);
    }

    #[test]
    fn test_generate_demo_output() {
        let input = "Build a todo app";
        let output = generate_demo_output(input).unwrap();
        assert!(output.prd.is_some());
        assert!(output.ard.is_some());
        assert!(output.task_list.is_some());
        assert!(output.agent_rules.is_some());
    }

    #[test]
    fn test_empty_input_returns_error() {
        let result = generate_demo_output("");
        assert!(result.is_err());
    }
}
